// Code generation tool for Azure region mapping
// This tool generates the mapClusterRegionToPricingRegion function
// by fetching actual Azure regions and pricing API regions.

//go:build generate

package main

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"sort"
	"text/template"
	"time"
)

// AzureLocation represents an Azure location from the locations API
type AzureLocation struct {
	Name         string `json:"name"`
	DisplayName  string `json:"displayName"`
	RegionalDisplayName string `json:"regionalDisplayName,omitempty"`
}

// PricingRegion represents a region from the Azure Retail Prices API
type PricingRegion struct {
	ArmRegionName string `json:"armRegionName"`
	Location      string `json:"location"`
}

// RegionMapping represents the final mapping between ARM regions and pricing regions
type RegionMapping struct {
	ARMRegion     string
	PricingRegion string
	Comment       string
}

const (
	// Azure Management API endpoint for locations (requires auth, so we'll use a fallback approach)
	// locationsAPI = "https://management.azure.com/subscriptions/{subscription-id}/locations"
	
	// Azure Retail Prices API endpoint for discovering available regions
	pricingRegionsAPI = "https://prices.azure.com/api/retail/prices?api-version=2023-01-01-preview&$top=1000"
	
	// Template for generating the Go code
	regionMappingTemplate = `// Code generated by go generate; DO NOT EDIT.
// Generated at: {{.Timestamp}}

package aks

// mapClusterRegionToPricingRegion maps Azure cluster region names to Azure Retail Prices API region names.
// The pricing API uses different region naming conventions than ARM resources.
// Example: "centralus" (ARM) -> "US Central" (Pricing API)
//
// This function is auto-generated from the Azure Retail Prices API.
// To regenerate: go generate ./pkg/azure/aks
func (ds *DiskStore) mapClusterRegionToPricingRegion(clusterRegion string) string {
	// Generated mapping based on Azure Retail Prices API region names
	regionMap := map[string]string{
{{- range .Mappings}}
		"{{.ARMRegion}}": "{{.PricingRegion}}", // {{.Comment}}
{{- end}}
	}

	if pricingRegion, ok := regionMap[clusterRegion]; ok {
		return pricingRegion
	}

	// Fallback: return the original region name if no mapping found
	// This allows the system to continue working with new regions
	return clusterRegion
}
`
)

func main() {
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	log.Println("Generating Azure region mapping...")

	// Fetch pricing regions from Azure Retail Prices API
	pricingRegions, err := fetchPricingRegions(ctx)
	if err != nil {
		log.Fatalf("Failed to fetch pricing regions: %v", err)
	}

	log.Printf("Found %d unique pricing regions", len(pricingRegions))

	// Create region mappings
	mappings := createRegionMappings(pricingRegions)
	
	// Sort mappings by ARM region name for consistent output
	sort.Slice(mappings, func(i, j int) bool {
		return mappings[i].ARMRegion < mappings[j].ARMRegion
	})

	// Generate the Go code
	if err := generateRegionMappingCode(mappings); err != nil {
		log.Fatalf("Failed to generate code: %v", err)
	}

	log.Printf("Successfully generated region mapping with %d entries", len(mappings))
}

func fetchPricingRegions(ctx context.Context) (map[string]string, error) {
	req, err := http.NewRequestWithContext(ctx, "GET", pricingRegionsAPI, nil)
	if err != nil {
		return nil, fmt.Errorf("creating request: %w", err)
	}

	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("making request: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("API request failed with status %d", resp.StatusCode)
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("reading response body: %w", err)
	}

	var apiResponse struct {
		Items []PricingRegion `json:"Items"`
	}

	if err := json.Unmarshal(body, &apiResponse); err != nil {
		return nil, fmt.Errorf("unmarshaling response: %w", err)
	}

	// Create a unique map of ARM region -> pricing region
	regions := make(map[string]string)
	for _, item := range apiResponse.Items {
		if item.ArmRegionName != "" && item.Location != "" {
			regions[item.ArmRegionName] = item.Location
		}
	}

	return regions, nil
}

func createRegionMappings(pricingRegions map[string]string) []RegionMapping {
	var mappings []RegionMapping

	// Convert the map to a slice of RegionMapping structs
	for armRegion, pricingRegion := range pricingRegions {
		comment := fmt.Sprintf("Auto-generated: %s -> %s", armRegion, pricingRegion)
		
		mappings = append(mappings, RegionMapping{
			ARMRegion:     armRegion,
			PricingRegion: pricingRegion,
			Comment:       comment,
		})
	}

	return mappings
}

func generateRegionMappingCode(mappings []RegionMapping) error {
	tmpl, err := template.New("regionMapping").Parse(regionMappingTemplate)
	if err != nil {
		return fmt.Errorf("parsing template: %w", err)
	}

	// Create output file
	outputFile := "region_mapping_generated.go"
	file, err := os.Create(outputFile)
	if err != nil {
		return fmt.Errorf("creating output file: %w", err)
	}
	defer file.Close()

	// Execute template
	data := struct {
		Timestamp time.Time
		Mappings  []RegionMapping
	}{
		Timestamp: time.Now(),
		Mappings:  mappings,
	}

	if err := tmpl.Execute(file, data); err != nil {
		return fmt.Errorf("executing template: %w", err)
	}

	log.Printf("Generated %s with %d region mappings", outputFile, len(mappings))
	return nil
}