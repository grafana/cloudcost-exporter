// Code generation tool for Azure disk SKU/tier mapping
// This tool generates disk SKU lookup functions by fetching actual Azure disk pricing tiers.

//go:build generate

package main

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"regexp"
	"sort"
	"strings"
	"text/template"
	"time"
)

// DiskSKU represents a disk SKU with size and pricing information
type DiskSKU struct {
	SKUName    string
	TierName   string
	SizeGB     int
	DiskType   string // Standard_LRS, StandardSSD_LRS, Premium_LRS
	ProductName string
}

const (
	// Azure Retail Prices API endpoint for disk pricing
	diskPricingAPI = "https://prices.azure.com/api/retail/prices?api-version=2023-01-01-preview&$filter=serviceName eq 'Storage' and contains(productName, 'Managed Disk') and priceType eq 'Consumption'&$top=1000"
	
	// Template for generating the Go code
	diskSKUTemplate = `// Code generated by go generate; DO NOT EDIT.
// Generated at: {{.Timestamp}}

package aks

import "strings"

{{range .DiskTypes}}
// {{.FuncName}} returns the Azure disk SKU name for {{.TypeName}} based on disk size.
// Auto-generated from Azure Retail Prices API disk pricing tiers.
func (ds *DiskStore) {{.FuncName}}(sizeGB int32) string {
{{- range .SKUs}}
	{{.Condition}} {
		return "{{.SKUName}}"{{.Comment}}
{{- end}}
	} else {
		return "{{.DefaultSKU}}" // Fallback for very large disks
	}
}
{{end}}

// extractTierFromSKU extracts the pricing tier from a disk SKU name.
// Auto-generated helper function.
func extractTierFromSKU(sku string) string {
	parts := strings.Fields(sku)
	if len(parts) > 0 {
		return parts[0]
	}
	return "Unknown"
}
`
)

// DiskTypeMapping represents the generated functions for each disk type
type DiskTypeMapping struct {
	FuncName    string
	TypeName    string
	SKUs        []SKUCondition
	DefaultSKU  string
}

// SKUCondition represents a size condition and corresponding SKU
type SKUCondition struct {
	Condition string
	SKUName   string
	Comment   string
}

func main() {
	ctx, cancel := context.WithTimeout(context.Background(), 60*time.Second)
	defer cancel()

	log.Println("Generating Azure disk SKU/tier mapping...")

	// Fetch disk pricing data from Azure Retail Prices API
	diskSKUs, err := fetchDiskSKUs(ctx)
	if err != nil {
		log.Fatalf("Failed to fetch disk SKUs: %v", err)
	}

	log.Printf("Found %d disk SKUs", len(diskSKUs))

	// Process SKUs by disk type
	diskTypeMappings := processDiskSKUs(diskSKUs)
	
	// Generate the Go code
	if err := generateDiskSKUCode(diskTypeMappings); err != nil {
		log.Fatalf("Failed to generate code: %v", err)
	}

	log.Printf("Successfully generated disk SKU mapping with %d disk types", len(diskTypeMappings))
}

func fetchDiskSKUs(ctx context.Context) ([]DiskSKU, error) {
	req, err := http.NewRequestWithContext(ctx, "GET", diskPricingAPI, nil)
	if err != nil {
		return nil, fmt.Errorf("creating request: %w", err)
	}

	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("making request: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("API request failed with status %d", resp.StatusCode)
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("reading response body: %w", err)
	}

	var apiResponse struct {
		Items []struct {
			ProductName string `json:"productName"`
			SKUName     string `json:"skuName"`
			MeterName   string `json:"meterName"`
		} `json:"Items"`
	}

	if err := json.Unmarshal(body, &apiResponse); err != nil {
		return nil, fmt.Errorf("unmarshaling response: %w", err)
	}

	var diskSKUs []DiskSKU
	
	// Parse disk SKUs from the API response
	for _, item := range apiResponse.Items {
		if sku := parseDiskSKU(item.ProductName, item.SKUName, item.MeterName); sku != nil {
			diskSKUs = append(diskSKUs, *sku)
		}
	}

	return diskSKUs, nil
}

func parseDiskSKU(productName, skuName, meterName string) *DiskSKU {
	// Only process managed disk products
	if !strings.Contains(productName, "Managed Disk") {
		return nil
	}

	// Extract tier and size from SKU name
	// Examples: "P4 LRS", "E10 LRS", "S30 LRS"
	tierPattern := regexp.MustCompile(`^([PSE]\d+)\s+LRS$`)
	matches := tierPattern.FindStringSubmatch(skuName)
	if len(matches) < 2 {
		return nil
	}

	tierName := matches[1]
	
	// Extract size from meter name or use known mappings
	sizeGB := extractSizeFromTier(tierName)
	if sizeGB == 0 {
		return nil
	}

	// Determine disk type based on tier prefix
	var diskType string
	switch tierName[0] {
	case 'P':
		diskType = "Premium_LRS"
	case 'E':
		diskType = "StandardSSD_LRS"
	case 'S':
		diskType = "Standard_LRS"
	default:
		return nil
	}

	return &DiskSKU{
		SKUName:     fmt.Sprintf("%s LRS Disk", tierName),
		TierName:    tierName,
		SizeGB:      sizeGB,
		DiskType:    diskType,
		ProductName: productName,
	}
}

func extractSizeFromTier(tierName string) int {
	// Known Azure disk tier to size mappings
	tierSizes := map[string]int{
		// Premium SSD (P-series)
		"P4": 32, "P6": 64, "P10": 128, "P15": 256, "P20": 512,
		"P30": 1024, "P40": 2048, "P50": 4096, "P60": 8192, "P70": 16384, "P80": 32768,
		
		// Standard SSD (E-series)
		"E1": 4, "E2": 8, "E3": 16, "E4": 32, "E6": 64, "E10": 128,
		"E15": 256, "E20": 512, "E30": 1024, "E40": 2048, "E50": 4096,
		"E60": 8192, "E70": 16384, "E80": 32768,
		
		// Standard HDD (S-series)
		"S4": 32, "S6": 64, "S10": 128, "S15": 256, "S20": 512,
		"S30": 1024, "S40": 2048, "S50": 4096, "S60": 8192, "S70": 16384, "S80": 32768,
	}
	
	return tierSizes[tierName]
}

func processDiskSKUs(diskSKUs []DiskSKU) []DiskTypeMapping {
	// Group SKUs by disk type and deduplicate by tier
	typeGroups := make(map[string]map[string]DiskSKU)
	for _, sku := range diskSKUs {
		if typeGroups[sku.DiskType] == nil {
			typeGroups[sku.DiskType] = make(map[string]DiskSKU)
		}
		// Use tier name as key to deduplicate
		typeGroups[sku.DiskType][sku.TierName] = sku
	}

	var mappings []DiskTypeMapping

	// Process each disk type
	for diskType, tierMap := range typeGroups {
		// Convert map to slice
		var skus []DiskSKU
		for _, sku := range tierMap {
			skus = append(skus, sku)
		}
		
		// Sort by size
		sort.Slice(skus, func(i, j int) bool {
			return skus[i].SizeGB < skus[j].SizeGB
		})

		funcName := getFunctionName(diskType)
		typeName := getTypeName(diskType)
		
		var conditions []SKUCondition
		for i, sku := range skus {
			var condition string
			if i == 0 {
				condition = fmt.Sprintf("if sizeGB <= %d", sku.SizeGB)
			} else {
				condition = fmt.Sprintf("} else if sizeGB <= %d", sku.SizeGB)
			}
			
			comment := fmt.Sprintf(" // %dGB", sku.SizeGB)
			
			conditions = append(conditions, SKUCondition{
				Condition: condition,
				SKUName:   sku.SKUName,
				Comment:   comment,
			})
		}

		// Default to largest available SKU
		defaultSKU := skus[len(skus)-1].SKUName
		
		mappings = append(mappings, DiskTypeMapping{
			FuncName:   funcName,
			TypeName:   typeName,
			SKUs:       conditions,
			DefaultSKU: defaultSKU,
		})
	}

	// Sort mappings for consistent output
	sort.Slice(mappings, func(i, j int) bool {
		return mappings[i].FuncName < mappings[j].FuncName
	})

	return mappings
}

func getFunctionName(diskType string) string {
	switch diskType {
	case "Premium_LRS":
		return "getPremiumSSDSKU"
	case "StandardSSD_LRS":
		return "getStandardSSDSKU"
	case "Standard_LRS":
		return "getStandardHDDSKU"
	default:
		return "getUnknownSKU"
	}
}

func getTypeName(diskType string) string {
	switch diskType {
	case "Premium_LRS":
		return "Premium SSD"
	case "StandardSSD_LRS":
		return "Standard SSD"
	case "Standard_LRS":
		return "Standard HDD"
	default:
		return "Unknown"
	}
}

func generateDiskSKUCode(mappings []DiskTypeMapping) error {
	tmpl, err := template.New("diskSKU").Parse(diskSKUTemplate)
	if err != nil {
		return fmt.Errorf("parsing template: %w", err)
	}

	// Create output file
	outputFile := "disk_skus_generated.go"
	file, err := os.Create(outputFile)
	if err != nil {
		return fmt.Errorf("creating output file: %w", err)
	}
	defer file.Close()

	// Execute template
	data := struct {
		Timestamp time.Time
		DiskTypes []DiskTypeMapping
	}{
		Timestamp: time.Now(),
		DiskTypes: mappings,
	}

	if err := tmpl.Execute(file, data); err != nil {
		return fmt.Errorf("executing template: %w", err)
	}

	log.Printf("Generated %s with %d disk type mappings", outputFile, len(mappings))
	return nil
}