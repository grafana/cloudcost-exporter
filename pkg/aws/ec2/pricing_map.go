package ec2

import (
	"encoding/json"
	"errors"
	"fmt"
	"log"
	"log/slog"
	"strconv"
	"strings"
	"sync"

	ec2Types "github.com/aws/aws-sdk-go-v2/service/ec2/types"
)

const (
	defaultInstanceFamily = "General purpose"
)

var (
	ErrInstanceTypeAlreadyExists = errors.New("instance type already exists in the map")
	ErrParseAttributes           = errors.New("error parsing attribute")
	ErrRegionNotFound            = errors.New("no region found")
	ErrInstanceTypeNotFound      = errors.New("no instance type found")
	ErrVolumeTypeNotFound        = errors.New("volume type not found")
	ErrListSpotPrices            = errors.New("error listing spot prices")
	ErrListOnDemandPrices        = errors.New("error listing ondemand prices")
	ErrListStoragePrices         = errors.New("error listing storage prices")
)

// cpuToCostRatio was generated by analysing Grafana Labs spend in GCP and finding the ratio of CPU to Memory spend by instance type.
// It's an imperfect approximation, but it's better than nothing.
var cpuToCostRatio = map[string]float64{
	"Compute optimized": 0.88,
	"Memory optimized":  0.48,
	"General purpose":   0.65,
	"Storage optimized": 0.48,
}

// ComputePricingMap collects a map of FamilyPricing structs where the key is the region
type ComputePricingMap struct {
	// Regions is a map of region code to FamilyPricing
	// key is the region
	// value is a map of instance type to PriceTiers
	Regions         map[string]*FamilyPricing
	InstanceDetails map[string]InstanceAttributes
	m               sync.RWMutex
	logger          *slog.Logger
}

// FamilyPricing is a map of instance type to a list of PriceTiers where the key is the ec2 compute instance type
type FamilyPricing struct {
	Family map[string]*Prices // Each Family can have many PriceTiers
}

// ComputePrices holds the price of a ec2 instances CPU and RAM. The price is in USD
type Prices struct {
	Cpu   float64
	Ram   float64
	Total float64
}

// StoragePricingMap collects a map of StoragePricing structs where the key is the region
type StoragePricingMap struct {
	// Regions is a map of region code to StoragePricing
	// key is the region
	// value is a map of storage classes to prices
	Regions map[string]*StoragePricing
	m       sync.RWMutex
	logger  *slog.Logger
}

// StoragePricing is a map where the key is the storage type and the value is the price
type StoragePricing struct {
	Storage map[string]float64
}

func NewComputePricingMap(l *slog.Logger) *ComputePricingMap {
	return &ComputePricingMap{
		Regions:         make(map[string]*FamilyPricing),
		InstanceDetails: make(map[string]InstanceAttributes),
		m:               sync.RWMutex{},
		logger:          l.With("subsystem", "computePricing"),
	}
}

func NewStoragePricingMap(l *slog.Logger) *StoragePricingMap {
	return &StoragePricingMap{
		Regions: make(map[string]*StoragePricing),
		m:       sync.RWMutex{},
		logger:  l.With("subsystem", "storagePricing"),
	}
}

// GenerateComputePricingMap accepts a list of ondemand prices and a list of spot prices.
// The method needs to
// 1. Parse out the ondemand prices and generate a productTerm map for each instance type
// 2. Parse out spot prices and use the productTerm map to generate a spot price map
func (cpm *ComputePricingMap) GenerateComputePricingMap(ondemandPrices []string, spotPrices []ec2Types.SpotPrice) error {
	for _, product := range ondemandPrices {
		var productInfo computeProduct
		if err := json.Unmarshal([]byte(product), &productInfo); err != nil {
			return err
		}
		if productInfo.Product.Attributes.InstanceType == "" {
			// If there are no instance types, let's just continue on. This is the most important key
			continue
		}
		for _, term := range productInfo.Terms.OnDemand {
			for _, priceDimension := range term.PriceDimensions {
				price, err := strconv.ParseFloat(priceDimension.PricePerUnit["USD"], 64)
				if err != nil {
					cpm.logger.Error(fmt.Sprintf("error parsing price: %s, skipping", err))
					continue
				}
				err = cpm.AddToComputePricingMap(price, productInfo.Product.Attributes)
				if err != nil {
					switch {
					case errors.Is(err, ErrInstanceTypeAlreadyExists):
						// Only warn in debug mode about this error, since we only want one price per instance type
						cpm.logger.Debug(fmt.Sprintf("skipping addition to pricing map: %s", err))
						continue
					default:
						cpm.logger.Error(fmt.Sprintf("error adding to pricing map: %s", err))
						continue
					}
				}
				cpm.AddInstanceDetails(productInfo.Product.Attributes)
			}
		}
	}
	for _, spotPrice := range spotPrices {
		region := *spotPrice.AvailabilityZone
		instanceType := string(spotPrice.InstanceType)
		if _, ok := cpm.InstanceDetails[instanceType]; !ok {
			cpm.logger.Error(fmt.Sprintf("no instance details found for instance type %s", instanceType))
			continue
		}
		spotProductTerm := cpm.InstanceDetails[instanceType]
		// Override the region with the availability zone
		spotProductTerm.Region = region
		price, err := strconv.ParseFloat(*spotPrice.SpotPrice, 64)
		if err != nil {
			cpm.logger.Error(fmt.Sprintf("error parsing spot price: %s, skipping", err))
			continue
		}
		err = cpm.AddToComputePricingMap(price, spotProductTerm)
		if err != nil {
			switch {
			case errors.Is(err, ErrInstanceTypeAlreadyExists):
				// Only warn in debug mode about this error, since we only want one price per instance type
				cpm.logger.Debug(fmt.Sprintf("skipping addition to pricing map: %s", err))
				continue
			default:
				cpm.logger.Error(fmt.Sprintf("error adding to pricing map: %s", err))
				continue
			}
		}
	}
	return nil
}

// GenerateStoragePricingMap receives a json with all the prices of the available storage options
// It iterates over the storage classes and parses the price for each one.
func (spm *StoragePricingMap) GenerateStoragePricingMap(storagePrices []string) error {
	spm.m.Lock()
	defer spm.m.Unlock()

	for _, product := range storagePrices {
		var productInfo storageProduct
		if err := json.Unmarshal([]byte(product), &productInfo); err != nil {
			return err
		}

		region := productInfo.Product.Attributes.Region
		storageClass := productInfo.Product.Attributes.VolumeApiName
		if spm.Regions[region] == nil {
			spm.Regions[region] = &StoragePricing{}
			spm.Regions[region].Storage = make(map[string]float64)
		}

		for _, term := range productInfo.Terms.OnDemand {
			for _, priceDimension := range term.PriceDimensions {
				price, err := strconv.ParseFloat(priceDimension.PricePerUnit["USD"], 64)
				if err != nil {
					spm.logger.Error(fmt.Sprintf("error parsing price: %s, skipping", err))
					continue
				}
				spm.Regions[region].Storage[storageClass] = price
			}
		}
	}

	return nil
}

// AddToComputePricingMap adds a price to the compute pricing map. The price is weighted based upon the instance type's CPU and RAM.
func (cpm *ComputePricingMap) AddToComputePricingMap(price float64, attribute InstanceAttributes) error {
	cpm.m.Lock()
	defer cpm.m.Unlock()
	if cpm.Regions[attribute.Region] == nil {
		cpm.Regions[attribute.Region] = &FamilyPricing{}
		cpm.Regions[attribute.Region].Family = make(map[string]*Prices)
	}

	if cpm.Regions[attribute.Region].Family[attribute.InstanceType] != nil {
		return ErrInstanceTypeAlreadyExists
	}

	weightedPrice, err := weightedPriceForInstance(price, attribute)
	if err != nil {
		return err
	}
	cpm.Regions[attribute.Region].Family[attribute.InstanceType] = &Prices{
		Cpu:   weightedPrice.Cpu,
		Ram:   weightedPrice.Ram,
		Total: price,
	}
	return nil
}

func (cpm *ComputePricingMap) AddInstanceDetails(attributes InstanceAttributes) {
	cpm.m.Lock()
	defer cpm.m.Unlock()
	if _, ok := cpm.InstanceDetails[attributes.InstanceType]; !ok {
		cpm.InstanceDetails[attributes.InstanceType] = attributes
	}
}

func weightedPriceForInstance(price float64, attributes InstanceAttributes) (*Prices, error) {
	cpus, err := strconv.ParseFloat(attributes.VCPU, 64)
	if err != nil {
		return nil, fmt.Errorf("%w %w", ErrParseAttributes, err)
	}
	if strings.Contains(attributes.Memory, " GiB") {
		attributes.Memory = strings.TrimSuffix(attributes.Memory, " GiB")
	}
	ram, err := strconv.ParseFloat(attributes.Memory, 64)
	if err != nil {
		return nil, fmt.Errorf("%w: %w", ErrParseAttributes, err)
	}
	ratio, ok := cpuToCostRatio[attributes.InstanceFamily]
	if !ok {
		log.Printf("no ratio found for instance type %s, defaulting to %s", attributes.InstanceType, defaultInstanceFamily)
		ratio = cpuToCostRatio[defaultInstanceFamily]
	}

	return &Prices{
		Cpu: price * ratio / cpus,
		Ram: price * (1 - ratio) / ram,
	}, nil
}

func (cpm *ComputePricingMap) GetPriceForInstanceType(region string, instanceType string) (*Prices, error) {
	cpm.m.RLock()
	defer cpm.m.RUnlock()
	if _, ok := cpm.Regions[region]; !ok {
		return nil, ErrRegionNotFound
	}
	price := cpm.Regions[region].Family[instanceType]
	if price == nil {
		return nil, ErrInstanceTypeNotFound
	}
	return cpm.Regions[region].Family[instanceType], nil
}

func (spm *StoragePricingMap) GetPriceForVolumeType(region string, volumeType string, size int32) (float64, error) {
	spm.m.RLock()
	defer spm.m.RUnlock()

	if _, ok := spm.Regions[region]; !ok {
		return 0, ErrRegionNotFound
	}

	if _, ok := spm.Regions[region].Storage[volumeType]; !ok {
		return 0, ErrVolumeTypeNotFound
	}

	// Prices are listed in GB-Mo units (Gib/month, considering 30 day months).
	// Divide by 30 and 24 to get the hourly price.
	return spm.Regions[region].Storage[volumeType] * float64(size) / 30 / 24, nil
}

// InstanceAttributes represents ec2 instance attributes that are pulled from AWS api's describing instances.
// It's specifically pulled out of productTerm to enable usage during tests.
type InstanceAttributes struct {
	Region            string `json:"regionCode"`
	InstanceType      string `json:"instanceType"`
	VCPU              string `json:"vcpu"`
	Memory            string `json:"memory"`
	InstanceFamily    string `json:"instanceFamily"`
	PhysicalProcessor string `json:"physicalProcessor"`
	Tenancy           string `json:"tenancy"`
	MarketOption      string `json:"marketOption"`
	OperatingSystem   string `json:"operatingSystem"`
	ClockSpeed        string `json:"clockSpeed"`
	UsageType         string `json:"usageType"`
}

// computeProduct represents the nested json response returned by the AWS pricing API EC2
type computeProduct struct {
	Product struct {
		Attributes InstanceAttributes
	}
	Terms struct {
		OnDemand map[string]struct {
			PriceDimensions map[string]struct {
				PricePerUnit map[string]string `json:"pricePerUnit"`
			}
		}
	}
}

// storageProduct represents the nested json response returned by the AWS pricing API for EBS
type storageProduct struct {
	Product struct {
		Attributes struct {
			Region        string `json:"regionCode"`
			VolumeApiName string `json:"volumeApiName"`
		}
	}
	Terms struct {
		OnDemand map[string]struct {
			PriceDimensions map[string]struct {
				PricePerUnit map[string]string `json:"pricePerUnit"`
			}
		}
	}
}
