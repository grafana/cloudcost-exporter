package ec2

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"log"
	"log/slog"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/service/ec2"
	ec2Types "github.com/aws/aws-sdk-go-v2/service/ec2/types"
	"github.com/aws/aws-sdk-go-v2/service/pricing"
	"github.com/aws/aws-sdk-go-v2/service/pricing/types"

	ec2client "github.com/grafana/cloudcost-exporter/pkg/aws/services/ec2"
	pricingClient "github.com/grafana/cloudcost-exporter/pkg/aws/services/pricing"
	"github.com/grafana/cloudcost-exporter/pkg/pricingcsv"
)

const (
	defaultInstanceFamily = "General purpose"
)

var (
	ErrInstanceTypeAlreadyExists = errors.New("instance type already exists in the map")
	ErrParseAttributes           = errors.New("error parsing attribute")
	ErrRegionNotFound            = errors.New("no region found")
	ErrInstanceTypeNotFound      = errors.New("no instance type found")
	ErrVolumeTypeNotFound        = errors.New("volume type not found")
	ErrListSpotPrices            = errors.New("error listing spot prices")
	ErrListOnDemandPrices        = errors.New("error listing ondemand prices")
	ErrListStoragePrices         = errors.New("error listing storage prices")
)

// cpuToCostRatio was generated by analysing Grafana Labs spend in GCP and finding the ratio of CPU to Memory spend by instance type.
// It's an imperfect approximation, but it's better than nothing.
var cpuToCostRatio = map[string]float64{
	"Compute optimized": 0.88,
	"Memory optimized":  0.48,
	"General purpose":   0.65,
	"Storage optimized": 0.48,
}

// ComputePricingMap collects a map of FamilyPricing structs where the key is the region
type ComputePricingMap struct {
	// Regions is a map of region code to FamilyPricing
	// key is the region
	// value is a map of instance type to PriceTiers
	Regions         map[string]*FamilyPricing
	InstanceDetails map[string]InstanceAttributes
	m               sync.RWMutex
	logger          *slog.Logger
}

// FamilyPricing is a map of instance type to a list of PriceTiers where the key is the ec2 compute instance type
type FamilyPricing struct {
	Family map[string]*Prices // Each Family can have many PriceTiers
}

// ComputePrices holds the price of a ec2 instances CPU and RAM. The price is in USD
type Prices struct {
	Cpu   float64
	Ram   float64
	Total float64
}

// StoragePricingMap collects a map of StoragePricing structs where the key is the region
type StoragePricingMap struct {
	// Regions is a map of region code to StoragePricing
	// key is the region
	// value is a map of storage classes to prices
	Regions map[string]*StoragePricing
	m       sync.RWMutex
	logger  *slog.Logger
}

// StoragePricing is a map where the key is the storage type and the value is the price
type StoragePricing struct {
	Storage map[string]float64
}

func NewComputePricingMap(l *slog.Logger) *ComputePricingMap {
	return &ComputePricingMap{
		Regions:         make(map[string]*FamilyPricing),
		InstanceDetails: make(map[string]InstanceAttributes),
		m:               sync.RWMutex{},
		logger:          l.With("subsystem", "computePricing"),
	}
}

func NewStoragePricingMap(l *slog.Logger) *StoragePricingMap {
	return &StoragePricingMap{
		Regions: make(map[string]*StoragePricing),
		m:       sync.RWMutex{},
		logger:  l.With("subsystem", "storagePricing"),
	}
}

func (cpm *ComputePricingMap) ToCSV(path string) error {
	csvWriter, err := pricingcsv.NewCSVWriter(path)
	if err != nil {
		return err
	}
	defer csvWriter.Close()

	for region, regionData := range cpm.Regions {
		for instanceType, instanceData := range regionData.Family {
			regionName := region
			capacityType := "on_demand"
			lastRegionChar := region[len(region)-1:]
			if lastRegionChar >= "a" && lastRegionChar <= "z" {
				regionName = region[:len(region)-1]
				capacityType = "spot"
			}

			record := pricingcsv.Entry{
				Provider:     "aws",
				Service:      "compute",
				Region:       regionName,
				Zone:         region,
				InstanceType: instanceType,
				CapacityType: capacityType,
				Price:        instanceData.Total,
				PricePerCore: instanceData.Cpu,
				PricePerGiB:  instanceData.Ram,
			}

			csvWriter.AddEntry(&record)
		}
	}
	return nil
}

// GenerateComputePricingMap accepts a list of ondemand prices and a list of spot prices.
// The method needs to
// 1. Parse out the ondemand prices and generate a productTerm map for each instance type
// 2. Parse out spot prices and use the productTerm map to generate a spot price map
func (cpm *ComputePricingMap) GenerateComputePricingMap(ondemandPrices []string, spotPrices []ec2Types.SpotPrice) error {
	for _, product := range ondemandPrices {
		var productInfo computeProduct
		if err := json.Unmarshal([]byte(product), &productInfo); err != nil {
			return err
		}
		if productInfo.Product.Attributes.InstanceType == "" {
			// If there are no instance types, let's just continue on. This is the most important key
			continue
		}
		for _, term := range productInfo.Terms.OnDemand {
			for _, priceDimension := range term.PriceDimensions {
				price, err := strconv.ParseFloat(priceDimension.PricePerUnit["USD"], 64)
				if err != nil {
					cpm.logger.Error(fmt.Sprintf("error parsing price: %s, skipping", err))
					continue
				}
				err = cpm.AddToComputePricingMap(price, productInfo.Product.Attributes)
				if err != nil {
					cpm.logger.Error(fmt.Sprintf("error adding to pricing map: %s", err))
					continue
				}
				cpm.AddInstanceDetails(productInfo.Product.Attributes)
			}
		}
	}
	for _, spotPrice := range spotPrices {
		region := *spotPrice.AvailabilityZone
		instanceType := string(spotPrice.InstanceType)
		if _, ok := cpm.InstanceDetails[instanceType]; !ok {
			cpm.logger.Error(fmt.Sprintf("no instance details found for instance type %s", instanceType))
			continue
		}
		spotProductTerm := cpm.InstanceDetails[instanceType]
		// Override the region with the availability zone
		spotProductTerm.Region = region
		price, err := strconv.ParseFloat(*spotPrice.SpotPrice, 64)
		if err != nil {
			cpm.logger.Error(fmt.Sprintf("error parsing spot price: %s, skipping", err))
			continue
		}
		err = cpm.AddToComputePricingMap(price, spotProductTerm)
		if err != nil {
			cpm.logger.Error(fmt.Sprintf("error adding to pricing map: %s", err))
			continue
		}
	}
	return nil
}

func (spm *StoragePricingMap) ToCSV(path string) error {
	csvWriter, err := pricingcsv.NewCSVWriter(path)
	if err != nil {
		return err
	}
	defer csvWriter.Close()

	for region, regionData := range spm.Regions {
		for storageType, price := range regionData.Storage {
			regionName := region
			lastRegionChar := region[len(region)-1:]
			if lastRegionChar >= "a" && lastRegionChar <= "z" {
				regionName = region[:len(region)-1]
			}

			record := pricingcsv.Entry{
				Provider:    "aws",
				Service:     "storage",
				Region:      regionName,
				Zone:        region,
				StorageType: storageType,
				Price:       price,
			}

			csvWriter.AddEntry(&record)
		}
	}
	return nil
}

// GenerateStoragePricingMap receives a json with all the prices of the available storage options
// It iterates over the storage classes and parses the price for each one.
func (spm *StoragePricingMap) GenerateStoragePricingMap(storagePrices []string) error {
	spm.m.Lock()
	defer spm.m.Unlock()

	for _, product := range storagePrices {
		var productInfo storageProduct
		if err := json.Unmarshal([]byte(product), &productInfo); err != nil {
			return err
		}

		region := productInfo.Product.Attributes.Region
		storageClass := productInfo.Product.Attributes.VolumeApiName
		if spm.Regions[region] == nil {
			spm.Regions[region] = &StoragePricing{}
			spm.Regions[region].Storage = make(map[string]float64)
		}

		for _, term := range productInfo.Terms.OnDemand {
			for _, priceDimension := range term.PriceDimensions {
				price, err := strconv.ParseFloat(priceDimension.PricePerUnit["USD"], 64)
				if err != nil {
					spm.logger.Error(fmt.Sprintf("error parsing price: %s, skipping", err))
					continue
				}
				spm.Regions[region].Storage[storageClass] = price
			}
		}
	}

	return nil
}

// AddToComputePricingMap adds a price to the compute pricing map. The price is weighted based upon the instance type's CPU and RAM.
func (cpm *ComputePricingMap) AddToComputePricingMap(price float64, attribute InstanceAttributes) error {
	cpm.m.Lock()
	defer cpm.m.Unlock()
	if cpm.Regions[attribute.Region] == nil {
		cpm.Regions[attribute.Region] = &FamilyPricing{}
		cpm.Regions[attribute.Region].Family = make(map[string]*Prices)
	}

	if cpm.Regions[attribute.Region].Family[attribute.InstanceType] != nil {
		return ErrInstanceTypeAlreadyExists
	}

	weightedPrice, err := weightedPriceForInstance(price, attribute)
	if err != nil {
		return err
	}
	cpm.Regions[attribute.Region].Family[attribute.InstanceType] = &Prices{
		Cpu:   weightedPrice.Cpu,
		Ram:   weightedPrice.Ram,
		Total: price,
	}
	return nil
}

func (cpm *ComputePricingMap) AddInstanceDetails(attributes InstanceAttributes) {
	cpm.m.Lock()
	defer cpm.m.Unlock()
	if _, ok := cpm.InstanceDetails[attributes.InstanceType]; !ok {
		cpm.InstanceDetails[attributes.InstanceType] = attributes
	}
}

func weightedPriceForInstance(price float64, attributes InstanceAttributes) (*Prices, error) {
	cpus, err := strconv.ParseFloat(attributes.VCPU, 64)
	if err != nil {
		return nil, fmt.Errorf("%w %w", ErrParseAttributes, err)
	}
	if strings.Contains(attributes.Memory, " GiB") {
		attributes.Memory = strings.TrimSuffix(attributes.Memory, " GiB")
	}
	ram, err := strconv.ParseFloat(attributes.Memory, 64)
	if err != nil {
		return nil, fmt.Errorf("%w: %w", ErrParseAttributes, err)
	}
	ratio, ok := cpuToCostRatio[attributes.InstanceFamily]
	if !ok {
		log.Printf("no ratio found for instance type %s, defaulting to %s", attributes.InstanceType, defaultInstanceFamily)
		ratio = cpuToCostRatio[defaultInstanceFamily]
	}

	return &Prices{
		Cpu: price * ratio / cpus,
		Ram: price * (1 - ratio) / ram,
	}, nil
}

func (cpm *ComputePricingMap) GetPriceForInstanceType(region string, instanceType string) (*Prices, error) {
	cpm.m.RLock()
	defer cpm.m.RUnlock()
	if _, ok := cpm.Regions[region]; !ok {
		return nil, ErrRegionNotFound
	}
	price := cpm.Regions[region].Family[instanceType]
	if price == nil {
		return nil, ErrInstanceTypeNotFound
	}
	return cpm.Regions[region].Family[instanceType], nil
}

func (spm *StoragePricingMap) GetPriceForVolumeType(region string, volumeType string, size int32) (float64, error) {
	spm.m.RLock()
	defer spm.m.RUnlock()

	if _, ok := spm.Regions[region]; !ok {
		return 0, ErrRegionNotFound
	}

	if _, ok := spm.Regions[region].Storage[volumeType]; !ok {
		return 0, ErrVolumeTypeNotFound
	}

	// Prices are listed in GB-Mo units (Gib/month, considering 30 day months).
	// Divide by 30 and 24 to get the hourly price.
	return spm.Regions[region].Storage[volumeType] * float64(size) / 30 / 24, nil
}

func (cpm *ComputePricingMap) CheckReadiness() bool {
	// TODO - implement
	return true
}

func (spm *StoragePricingMap) CheckReadiness() bool {
	// TODO - implement
	return true
}

// InstanceAttributes represents ec2 instance attributes that are pulled from AWS api's describing instances.
// It's specifically pulled out of productTerm to enable usage during tests.
type InstanceAttributes struct {
	Region            string `json:"regionCode"`
	InstanceType      string `json:"instanceType"`
	VCPU              string `json:"vcpu"`
	Memory            string `json:"memory"`
	InstanceFamily    string `json:"instanceFamily"`
	PhysicalProcessor string `json:"physicalProcessor"`
	Tenancy           string `json:"tenancy"`
	MarketOption      string `json:"marketOption"`
	OperatingSystem   string `json:"operatingSystem"`
	ClockSpeed        string `json:"clockSpeed"`
	UsageType         string `json:"usageType"`
}

// computeProduct represents the nested json response returned by the AWS pricing API EC2
type computeProduct struct {
	Product struct {
		Attributes InstanceAttributes
	}
	Terms struct {
		OnDemand map[string]struct {
			PriceDimensions map[string]struct {
				PricePerUnit map[string]string `json:"pricePerUnit"`
			}
		}
	}
}

// storageProduct represents the nested json response returned by the AWS pricing API for EBS
type storageProduct struct {
	Product struct {
		Attributes struct {
			Region        string `json:"regionCode"`
			VolumeApiName string `json:"volumeApiName"`
		}
	}
	Terms struct {
		OnDemand map[string]struct {
			PriceDimensions map[string]struct {
				PricePerUnit map[string]string `json:"pricePerUnit"`
			}
		}
	}
}

func ListOnDemandPrices(ctx context.Context, region string, client pricingClient.Pricing) ([]string, error) {
	input := &pricing.GetProductsInput{
		ServiceCode: aws.String("AmazonEC2"),
		Filters: []types.Filter{
			{
				Field: aws.String("regionCode"),
				Type:  types.FilterTypeTermMatch,
				Value: aws.String(region),
			},
			{
				// Limit output to only base installs
				Field: aws.String("preInstalledSw"),
				Type:  types.FilterTypeTermMatch,
				Value: aws.String("NA"),
			},
			{
				// Limit to shared tenancy machines
				Field: aws.String("tenancy"),
				Type:  types.FilterTypeTermMatch,
				Value: aws.String("shared"),
			},
			{
				// Limit to ec2 instances(ie, not bare metal)
				Field: aws.String("productFamily"),
				Type:  types.FilterTypeTermMatch,
				Value: aws.String("Compute Instance"),
			},
			{
				// RunInstances is the operation that we're interested in.
				Field: aws.String("operation"),
				Type:  types.FilterTypeTermMatch,
				Value: aws.String("RunInstances"),
			},
			{
				// This effectively filters only for ondemand pricing
				Field: aws.String("capacitystatus"),
				Type:  types.FilterTypeTermMatch,
				Value: aws.String("UnusedCapacityReservation"),
			},
			{
				// Only care about Linux. If there's a request for windows, remove this flag and expand the pricing map to include a key for operating system
				Field: aws.String("operatingSystem"),
				Type:  types.FilterTypeTermMatch,
				Value: aws.String("Linux"),
			},
		},
	}

	return getPricesFromProductList(ctx, input, client)
}

func ListSpotPrices(ctx context.Context, client ec2client.EC2) ([]ec2Types.SpotPrice, error) {
	var spotPrices []ec2Types.SpotPrice
	startTime := time.Now().Add(-time.Hour)
	endTime := time.Now()
	sphi := &ec2.DescribeSpotPriceHistoryInput{
		ProductDescriptions: []string{
			"Linux/UNIX (Amazon VPC)",
		},

		StartTime: &startTime,
		EndTime:   &endTime,
	}
	for {
		resp, err := client.DescribeSpotPriceHistory(ctx, sphi)
		if err != nil {
			// If there's an error, return the set of processed spotPrices and the error.
			return spotPrices, err
		}
		spotPrices = append(spotPrices, resp.SpotPriceHistory...)
		if resp.NextToken == nil || *resp.NextToken == "" {
			break
		}
		sphi.NextToken = resp.NextToken
	}
	return spotPrices, nil
}

func ListStoragePrices(ctx context.Context, region string, client pricingClient.Pricing) ([]string, error) {
	input := &pricing.GetProductsInput{
		ServiceCode: aws.String("AmazonEC2"),
		Filters: []types.Filter{
			{
				Field: aws.String("regionCode"),
				Type:  types.FilterTypeTermMatch,
				Value: aws.String(region),
			},
			// Get prices for EBS Volumes
			{
				Field: aws.String("productFamily"),
				Type:  types.FilterTypeTermMatch,
				Value: aws.String("Storage"),
			},
		},
	}

	return getPricesFromProductList(ctx, input, client)
}

func getPricesFromProductList(ctx context.Context, input *pricing.GetProductsInput, client pricingClient.Pricing) ([]string, error) {
	var productOutputs []string

	for {
		products, err := client.GetProducts(ctx, input)
		if err != nil {
			return productOutputs, err
		}

		if products == nil {
			break
		}

		productOutputs = append(productOutputs, products.PriceList...)
		if products.NextToken == nil || *products.NextToken == "" {
			break
		}
		input.NextToken = products.NextToken
	}
	return productOutputs, nil
}
