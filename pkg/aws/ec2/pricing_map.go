package ec2

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"log"
	"log/slog"
	"strconv"
	"strings"
	"sync"

	ec2Types "github.com/aws/aws-sdk-go-v2/service/ec2/types"
	"github.com/grafana/cloudcost-exporter/pkg/aws/client"
	"golang.org/x/sync/errgroup"
)

const (
	defaultInstanceFamily = "General purpose"
)

var (
	ErrInstanceTypeAlreadyExists = errors.New("instance type already exists in the map")
	ErrParseAttributes           = errors.New("error parsing attribute")
	ErrRegionNotFound            = errors.New("no region found")
	ErrInstanceTypeNotFound      = errors.New("no instance type found")
	ErrVolumeTypeNotFound        = errors.New("volume type not found")
	ErrListSpotPrices            = errors.New("error listing spot prices")
	ErrListOnDemandPrices        = errors.New("error listing ondemand prices")
	ErrListStoragePrices         = errors.New("error listing storage prices")
)

// cpuToCostRatio was generated by analysing Grafana Labs spend in GCP and finding the ratio of CPU to Memory spend by instance type.
// It's an imperfect approximation, but it's better than nothing.
var cpuToCostRatio = map[string]float64{
	"Compute optimized": 0.88,
	"Memory optimized":  0.48,
	"General purpose":   0.65,
	"Storage optimized": 0.48,
}

// ComputePricingMap collects a map of FamilyPricing structs where the key is the region
type ComputePricingMap struct {
	// Regions is a map of region code to FamilyPricing
	// key is the region
	// value is a map of instance type to PriceTiers
	Regions         map[string]*FamilyPricing
	InstanceDetails map[string]InstanceAttributes
	m               sync.RWMutex
	logger          *slog.Logger
	cfgRegions      []ec2Types.Region
	regionMap       map[string]client.Client
}

// FamilyPricing is a map of instance type to a list of PriceTiers where the key is the ec2 compute instance type
type FamilyPricing struct {
	Family map[string]*Prices // Each Family can have many PriceTiers
}

// ComputePrices holds the price of a ec2 instances CPU and RAM. The price is in USD
type Prices struct {
	Cpu   float64
	Ram   float64
	Total float64
}

// StoragePricingMap collects a map of StoragePricing structs where the key is the region
type StoragePricingMap struct {
	// Regions is a map of region code to StoragePricing
	// key is the region
	// value is a map of storage classes to prices
	Regions    map[string]*StoragePricing
	m          sync.RWMutex
	logger     *slog.Logger
	cfgRegions []ec2Types.Region
	regionMap  map[string]client.Client
}

// StoragePricing is a map where the key is the storage type and the value is the price
type StoragePricing struct {
	Storage map[string]float64
}

func NewComputePricingMap(l *slog.Logger, config *Config) *ComputePricingMap {
	return &ComputePricingMap{
		Regions:         make(map[string]*FamilyPricing),
		InstanceDetails: make(map[string]InstanceAttributes),
		m:               sync.RWMutex{},
		logger:          l.With("subsystem", "computePricing"),
		cfgRegions:      config.Regions,
		regionMap:       config.RegionMap,
	}
}

func NewStoragePricingMap(l *slog.Logger, config *Config) *StoragePricingMap {
	return &StoragePricingMap{
		Regions:    make(map[string]*StoragePricing),
		m:          sync.RWMutex{},
		logger:     l.With("subsystem", "storagePricing"),
		cfgRegions: config.Regions,
		regionMap:  config.RegionMap,
	}
}

func (cpm *ComputePricingMap) fetchPricing(ctx context.Context) ([]string, []ec2Types.SpotPrice, error) {
	var ondemandPrices []string
	var spotPrices []ec2Types.SpotPrice
	eg, errGroupCtx := errgroup.WithContext(ctx)
	eg.SetLimit(errGroupLimit)
	m := sync.Mutex{}
	for _, region := range cpm.cfgRegions {
		region := region
		eg.Go(func() error {
			cpm.logger.LogAttrs(errGroupCtx, slog.LevelDebug, "fetching compute pricing info", slog.String("region", *region.RegionName))

			regionClient, ok := cpm.regionMap[*region.RegionName]
			if !ok {
				return ErrClientNotFound
			}

			spotPriceList, err := regionClient.ListSpotPrices(errGroupCtx)
			if err != nil {
				return fmt.Errorf("%w: %w", ErrListSpotPrices, err)
			}

			priceList, err := regionClient.ListOnDemandPrices(errGroupCtx, *region.RegionName)
			if err != nil {
				return fmt.Errorf("%w: %w", ErrListOnDemandPrices, err)
			}

			m.Lock()
			spotPrices = append(spotPrices, spotPriceList...)
			ondemandPrices = append(ondemandPrices, priceList...)
			m.Unlock()
			return nil
		})
	}
	err := eg.Wait()
	if err != nil {
		return nil, nil, err
	}

	return ondemandPrices, spotPrices, nil
}

// GenerateComputePricingMap fetches spot and ondemand prices from AWS using the
// configured region clients. It then needs to:
// 1. Parse out the ondemand prices and generate a productTerm map for each instance type
// 2. Parse out spot prices and use the productTerm map to generate a spot price map
func (cpm *ComputePricingMap) GenerateComputePricingMap(ctx context.Context) error {
	cpm.logger.LogAttrs(ctx, slog.LevelInfo, "Refreshing compute pricing map")
	ondemandPrices, spotPrices, err := cpm.fetchPricing(ctx)
	if err != nil {
		cpm.logger.Error(fmt.Sprintf("error fetching compute pricing: %s", err))
		return err
	}

	// Clear existing data before refresh to ensure we have latest prices
	cpm.m.Lock()
	cpm.Regions = make(map[string]*FamilyPricing)
	cpm.InstanceDetails = make(map[string]InstanceAttributes)
	cpm.m.Unlock()

	// Process ondemand prices in batches with concurrent workers
	if err := cpm.processOnDemandPricesInBatches(ondemandPrices); err != nil {
		return err
	}

	// Process spot prices in batches with concurrent workers
	cpm.processSpotPricesInBatches(spotPrices)

	return nil
}

// processOnDemandPricesInBatches processes ondemand prices concurrently in batches
func (cpm *ComputePricingMap) processOnDemandPricesInBatches(ondemandPrices []string) error {
	const batchSize = 50
	const maxWorkers = 10

	// Create a channel for batches
	batchChan := make(chan []string, (len(ondemandPrices)/batchSize)+1)

	// Split prices into batches and send to channel
	for i := 0; i < len(ondemandPrices); i += batchSize {
		end := i + batchSize
		if end > len(ondemandPrices) {
			end = len(ondemandPrices)
		}
		batchChan <- ondemandPrices[i:end]
	}
	close(batchChan)

	// Limit concurrent workers
	numWorkers := maxWorkers
	if len(ondemandPrices)/batchSize+1 < numWorkers {
		numWorkers = len(ondemandPrices)/batchSize + 1
	}
	if numWorkers == 0 {
		numWorkers = 1
	}

	// Error channel to collect errors from workers
	errChan := make(chan error, numWorkers)

	var wg sync.WaitGroup
	for i := 0; i < numWorkers; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			for batch := range batchChan {
				if err := cpm.processOnDemandBatch(batch); err != nil {
					errChan <- err
					return
				}
			}
		}()
	}
	wg.Wait()
	close(errChan)

	// Return the first error encountered
	for err := range errChan {
		if err != nil {
			return err
		}
	}

	return nil
}

// processOnDemandBatch processes a batch of ondemand prices
func (cpm *ComputePricingMap) processOnDemandBatch(batch []string) error {
	for _, product := range batch {
		var productInfo computeProduct
		if err := json.Unmarshal([]byte(product), &productInfo); err != nil {
			return err
		}
		if productInfo.Product.Attributes.InstanceType == "" {
			// If there are no instance types, let's just continue on. This is the most important key
			continue
		}
		for _, term := range productInfo.Terms.OnDemand {
			for _, priceDimension := range term.PriceDimensions {
				price, err := strconv.ParseFloat(priceDimension.PricePerUnit["USD"], 64)
				if err != nil {
					cpm.logger.Error(fmt.Sprintf("error parsing price: %s, skipping", err))
					continue
				}
				err = cpm.AddToComputePricingMap(price, productInfo.Product.Attributes)
				if err != nil {
					if errors.Is(err, ErrInstanceTypeAlreadyExists) {
						// Only log at debug level since duplicates are expected in AWS pricing data
						cpm.logger.Debug(fmt.Sprintf("instance type %s already in pricing map, skipping duplicate", productInfo.Product.Attributes.InstanceType))
					} else {
						// Log other errors (e.g., parsing failures) at error level
						cpm.logger.Error(fmt.Sprintf("error adding %s to pricing map: %s", productInfo.Product.Attributes.InstanceType, err))
					}
					continue
				}
				cpm.AddInstanceDetails(productInfo.Product.Attributes)
			}
		}
	}
	return nil
}

// processSpotPricesInBatches processes spot prices concurrently in batches
func (cpm *ComputePricingMap) processSpotPricesInBatches(spotPrices []ec2Types.SpotPrice) {
	const batchSize = 50
	const maxWorkers = 10

	// Create a channel for batches
	batchChan := make(chan []ec2Types.SpotPrice, (len(spotPrices)/batchSize)+1)

	// Split prices into batches and send to channel
	for i := 0; i < len(spotPrices); i += batchSize {
		end := i + batchSize
		if end > len(spotPrices) {
			end = len(spotPrices)
		}
		batchChan <- spotPrices[i:end]
	}
	close(batchChan)

	// Limit concurrent workers
	numWorkers := maxWorkers
	if len(spotPrices)/batchSize+1 < numWorkers {
		numWorkers = len(spotPrices)/batchSize + 1
	}
	if numWorkers == 0 {
		numWorkers = 1
	}

	var wg sync.WaitGroup
	for i := 0; i < numWorkers; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			for batch := range batchChan {
				cpm.processSpotBatch(batch)
			}
		}()
	}
	wg.Wait()
}

// processSpotBatch processes a batch of spot prices
func (cpm *ComputePricingMap) processSpotBatch(batch []ec2Types.SpotPrice) {
	for _, spotPrice := range batch {
		region := *spotPrice.AvailabilityZone
		instanceType := string(spotPrice.InstanceType)

		// Use RLock for reading instance details
		cpm.m.RLock()
		instanceDetails, ok := cpm.InstanceDetails[instanceType]
		cpm.m.RUnlock()

		if !ok {
			// Log at debug level since some instance types (e.g., bare metal instances like i3.metal)
			// may not have ondemand pricing but do have spot pricing
			cpm.logger.Debug(fmt.Sprintf("no instance details found for instance type %s, skipping spot price", instanceType))
			continue
		}

		spotProductTerm := instanceDetails
		// Override the region with the availability zone
		spotProductTerm.Region = region
		price, err := strconv.ParseFloat(*spotPrice.SpotPrice, 64)
		if err != nil {
			cpm.logger.Error(fmt.Sprintf("error parsing spot price: %s, skipping", err))
			continue
		}
		err = cpm.AddToComputePricingMap(price, spotProductTerm)
		if err != nil {
			switch {
			case errors.Is(err, ErrInstanceTypeAlreadyExists):
				// Multiple spot prices can exist for the same instance type (one per AZ)
				// Only log at debug level to reduce noise
				cpm.logger.Debug(fmt.Sprintf("spot price already exists for instance type %s in region %s, skipping", instanceType, region))
				continue
			default:
				cpm.logger.Error(fmt.Sprintf("error adding spot price to pricing map: %s", err))
				continue
			}
		}
	}
}

// GenerateStoragePricingMap receives a json with all the prices of the available storage options
// It iterates over the storage classes and parses the price for each one.
func (spm *StoragePricingMap) fetchPricing(ctx context.Context) ([]string, error) {
	var storagePrices []string
	eg, ctx := errgroup.WithContext(ctx)
	eg.SetLimit(errGroupLimit)
	m := sync.Mutex{}
	for _, region := range spm.cfgRegions {
		region := region
		eg.Go(func() error {
			regionClient, ok := spm.regionMap[*region.RegionName]
			if !ok {
				return ErrClientNotFound
			}
			spm.logger.LogAttrs(ctx, slog.LevelDebug, "fetching storage pricing info", slog.String("region", *region.RegionName))
			storagePriceList, err := regionClient.ListStoragePrices(ctx, *region.RegionName)
			if err != nil {
				return fmt.Errorf("%w: %w", ErrListStoragePrices, err)
			}

			m.Lock()
			storagePrices = append(storagePrices, storagePriceList...)
			m.Unlock()
			return nil
		})
	}
	err := eg.Wait()
	if err != nil {
		return nil, err
	}

	return storagePrices, nil
}

func (spm *StoragePricingMap) GenerateStoragePricingMap(ctx context.Context) error {
	spm.logger.LogAttrs(ctx, slog.LevelInfo, "Refreshing storage pricing map")
	storagePrices, err := spm.fetchPricing(ctx)
	if err != nil {
		spm.logger.Error(fmt.Sprintf("error fetching storage pricing: %s", err))
		return err
	}

	spm.m.Lock()
	defer spm.m.Unlock()

	// Clear existing data before refresh
	spm.Regions = make(map[string]*StoragePricing)

	for _, product := range storagePrices {
		var productInfo storageProduct
		if err := json.Unmarshal([]byte(product), &productInfo); err != nil {
			return fmt.Errorf("%w: %w", ErrGeneratePricingMap, err)
		}

		region := productInfo.Product.Attributes.Region
		storageClass := productInfo.Product.Attributes.VolumeApiName
		if spm.Regions[region] == nil {
			spm.Regions[region] = &StoragePricing{}
			spm.Regions[region].Storage = make(map[string]float64)
		}

		for _, term := range productInfo.Terms.OnDemand {
			for _, priceDimension := range term.PriceDimensions {
				price, err := strconv.ParseFloat(priceDimension.PricePerUnit["USD"], 64)
				if err != nil {
					spm.logger.Error(fmt.Sprintf("error parsing price: %s, skipping", err))
					continue
				}
				spm.Regions[region].Storage[storageClass] = price
			}
		}
	}

	return nil
}

// AddToComputePricingMap adds a price to the compute pricing map. The price is weighted based upon the instance type's CPU and RAM.
func (cpm *ComputePricingMap) AddToComputePricingMap(price float64, attribute InstanceAttributes) error {
	cpm.m.Lock()
	defer cpm.m.Unlock()
	if cpm.Regions[attribute.Region] == nil {
		cpm.Regions[attribute.Region] = &FamilyPricing{}
		cpm.Regions[attribute.Region].Family = make(map[string]*Prices)
	}

	if cpm.Regions[attribute.Region].Family[attribute.InstanceType] != nil {
		return ErrInstanceTypeAlreadyExists
	}

	weightedPrice, err := weightedPriceForInstance(price, attribute)
	if err != nil {
		return err
	}
	cpm.Regions[attribute.Region].Family[attribute.InstanceType] = &Prices{
		Cpu:   weightedPrice.Cpu,
		Ram:   weightedPrice.Ram,
		Total: price,
	}
	return nil
}

func (cpm *ComputePricingMap) AddInstanceDetails(attributes InstanceAttributes) {
	cpm.m.Lock()
	defer cpm.m.Unlock()
	if _, ok := cpm.InstanceDetails[attributes.InstanceType]; !ok {
		cpm.InstanceDetails[attributes.InstanceType] = attributes
	}
}

func weightedPriceForInstance(price float64, attributes InstanceAttributes) (*Prices, error) {
	cpus, err := strconv.ParseFloat(attributes.VCPU, 64)
	if err != nil {
		return nil, fmt.Errorf("%w %w", ErrParseAttributes, err)
	}
	if strings.Contains(attributes.Memory, " GiB") {
		attributes.Memory = strings.TrimSuffix(attributes.Memory, " GiB")
	}
	ram, err := strconv.ParseFloat(attributes.Memory, 64)
	if err != nil {
		return nil, fmt.Errorf("%w: %w", ErrParseAttributes, err)
	}
	ratio, ok := cpuToCostRatio[attributes.InstanceFamily]
	if !ok {
		log.Printf("no ratio found for instance type %s, defaulting to %s", attributes.InstanceType, defaultInstanceFamily)
		ratio = cpuToCostRatio[defaultInstanceFamily]
	}

	return &Prices{
		Cpu: price * ratio / cpus,
		Ram: price * (1 - ratio) / ram,
	}, nil
}

func (cpm *ComputePricingMap) GetPriceForInstanceType(region string, instanceType string) (*Prices, error) {
	cpm.m.RLock()
	defer cpm.m.RUnlock()
	if _, ok := cpm.Regions[region]; !ok {
		return nil, ErrRegionNotFound
	}
	price := cpm.Regions[region].Family[instanceType]
	if price == nil {
		return nil, ErrInstanceTypeNotFound
	}
	return cpm.Regions[region].Family[instanceType], nil
}

// GetInstanceFamily returns the instance family for a given instance type.
// Returns empty string if the instance type is not found.
func (cpm *ComputePricingMap) GetInstanceFamily(instanceType string) string {
	cpm.m.RLock()
	defer cpm.m.RUnlock()
	if details, ok := cpm.InstanceDetails[instanceType]; ok {
		return details.InstanceFamily
	}
	return ""
}

func (spm *StoragePricingMap) GetPriceForVolumeType(region string, volumeType string, size int32) (float64, error) {
	spm.m.RLock()
	defer spm.m.RUnlock()

	if _, ok := spm.Regions[region]; !ok {
		return 0, ErrRegionNotFound
	}

	if _, ok := spm.Regions[region].Storage[volumeType]; !ok {
		return 0, ErrVolumeTypeNotFound
	}

	// Prices are listed in GB-Mo units (Gib/month, considering 30 day months).
	// Divide by 30 and 24 to get the hourly price.
	return spm.Regions[region].Storage[volumeType] * float64(size) / 30 / 24, nil
}

// InstanceAttributes represents ec2 instance attributes that are pulled from AWS api's describing instances.
// It's specifically pulled out of productTerm to enable usage during tests.
type InstanceAttributes struct {
	Region            string `json:"regionCode"`
	InstanceType      string `json:"instanceType"`
	VCPU              string `json:"vcpu"`
	Memory            string `json:"memory"`
	InstanceFamily    string `json:"instanceFamily"`
	PhysicalProcessor string `json:"physicalProcessor"`
	Tenancy           string `json:"tenancy"`
	MarketOption      string `json:"marketOption"`
	OperatingSystem   string `json:"operatingSystem"`
	ClockSpeed        string `json:"clockSpeed"`
	UsageType         string `json:"usageType"`
}

// computeProduct represents the nested json response returned by the AWS pricing API EC2
type computeProduct struct {
	Product struct {
		Attributes InstanceAttributes
	}
	Terms struct {
		OnDemand map[string]struct {
			PriceDimensions map[string]struct {
				PricePerUnit map[string]string `json:"pricePerUnit"`
			}
		}
	}
}

// storageProduct represents the nested json response returned by the AWS pricing API for EBS
type storageProduct struct {
	Product struct {
		Attributes struct {
			Region        string `json:"regionCode"`
			VolumeApiName string `json:"volumeApiName"`
		}
	}
	Terms struct {
		OnDemand map[string]struct {
			PriceDimensions map[string]struct {
				PricePerUnit map[string]string `json:"pricePerUnit"`
			}
		}
	}
}
